package org.vt.magnum.antimalware.main;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.vt.magnum.antimalware.features.*;

import weka.core.Attribute;
import weka.core.DenseInstance;
import weka.core.Instance;
import weka.core.Instances;

import android.app.Service;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Binder;
import android.os.IBinder;
import android.text.format.Time;
import android.util.Log;

/**
 * This collects the vectors
 * and periodically writes them to a file (if training
 * mode is enabled).
 * 
 * @author Brandon Amos
 * @version 2012.08.10
 */
public class MalwareService extends Service {
	private static final String TAG = "MalwareService";
	
	private final IBinder mBinder = new MalwareBinder();
	private Time time;
	private ScheduledExecutorService scheduledExecutor;
	
	private BatteryFeatures battFeatures;
	private ArrayList<INormalFeatures> normalFeatures;

	private WekaHelper wh;
	private ArrayList<Attribute> battAttributes;
	private ArrayList<Attribute> normalAttributes;
	private ArrayList<Attribute> classAttributes;
	private ArrayList<Attribute> attributes;
	private Instances instances;
	
	@Override
	public void onCreate() {
		time = new Time();
		
		battFeatures = new BatteryFeatures();
		
		normalFeatures = new ArrayList<INormalFeatures>(4);
		normalFeatures.add(new BinderFeatures());
		normalFeatures.add(new CPUFeatures());
		normalFeatures.add(new MemoryFeatures());
		normalFeatures.add(new NetworkFeatures());
		
		wh = WekaHelper.getInstance();
		
		initWeka();
		initExecutor();
	}
	
	/**
	 * 
	 */
	@SuppressWarnings("unchecked")
	private void initWeka() {
		battAttributes = battFeatures.getAttributes();
		
		normalAttributes = new ArrayList<Attribute>();
		for (INormalFeatures feature : normalFeatures ) {
			normalAttributes.addAll(feature.getAttributes());
		}
		
		classAttributes = new ArrayList<Attribute>();

		List<String> classVal = new ArrayList<String>(2);
		classVal.add("positive");
		classVal.add("negative");
		Attribute classAttribute = new Attribute("classification", classVal);
		classAttributes.add(classAttribute);
		
		attributes = wh.addLists(battAttributes, normalAttributes,
				classAttributes);
		instances = new Instances("relation", attributes, 0);
	}

	/**
	 * Sets up retrieval at a fixed interval.
	 */
	private void initExecutor() {
		scheduledExecutor = Executors.newScheduledThreadPool(1);
		
		scheduledExecutor.scheduleAtFixedRate(new Runnable() {
			public void run() {
				fetchSnapshot();
			}
		}, 1, 5, TimeUnit.SECONDS); 
	}
	
	@Override
	public IBinder onBind(Intent intent) {
		return mBinder;
	}
	
	@Override
	public boolean onUnbind(Intent intent) {
		return true;
	}
	
	/**
	 * Gets the data from all of the features and puts them in 
	 * a format for Weka to read.
	 */
	public void fetchSnapshot() {
		Log.d(TAG, "fetchSnapshot!");
		
		time.setToNow();
		
		IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
		Instance battInstances = battFeatures.getInstance(registerReceiver(null, filter));
		
		ArrayList<Instance> normalInstanceList = new ArrayList<Instance>(normalAttributes.size());
		for (INormalFeatures features : normalFeatures) {
			normalInstanceList.add(features.getInstance());
		}
		wh.resetAttributes(normalAttributes);
		Instance normalInstances = wh.mergeInstances(normalInstanceList);
		
		wh.resetAttributes(classAttributes);
		Instance classInstance = new DenseInstance(1);
		classInstance.setValue(
				classAttributes.get(0), wh.getClassification() );
		
		wh.resetAttributes(attributes);
		instances.add(wh.mergeInstances(
				battInstances, normalInstances, classInstance));
		instances.setClassIndex(attributes.size()-1);
		
		wh.writeArff(instances.toString());
	}
	
	public class MalwareBinder extends Binder {
		MalwareService getService() {
			return MalwareService.this;
		}
	}
}
