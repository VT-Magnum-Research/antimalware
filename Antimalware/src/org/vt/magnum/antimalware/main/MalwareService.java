package org.vt.magnum.antimalware.main;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.vt.magnum.antimalware.features.*;

import weka.core.Attribute;
import weka.core.DenseInstance;
import weka.core.Instance;
import weka.core.Instances;

import android.app.Service;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Binder;
import android.os.IBinder;
import android.text.format.Time;
import android.util.Log;

/**
 * This collects the vectors
 * and periodically writes them to a file (if training
 * mode is enabled).
 * 
 * @author Brandon Amos
 * @version 2012.08.10
 */
public class MalwareService extends Service {
	private static final String TAG = "MalwareService";
	
	private final IBinder _mBinder = new MalwareBinder();
	private Time _time;
	private ScheduledExecutorService _scheduledExecutor;
	
	private BatteryFeatures _battFeatures;
	private ArrayList<INormalFeatures> _normalFeatures;

	private WekaHelper _wh;
	private ArrayList<Attribute> _battAttributes;
	private ArrayList<Attribute> _normalAttributes;
	private ArrayList<Attribute> _classAttributes;
	private ArrayList<Attribute> _attributes;
	private Instances _instances;
	
	@Override
	public void onCreate() {
		_time = new Time();
		
		_battFeatures = new BatteryFeatures();
		
		_normalFeatures = new ArrayList<INormalFeatures>(4);
		_normalFeatures.add(new BinderFeatures());
		_normalFeatures.add(new CPUFeatures());
		_normalFeatures.add(new MemoryFeatures());
		_normalFeatures.add(new NetworkFeatures());
		
		_wh = WekaHelper.getInstance();
		
		initWeka();
		initExecutor();
	}
	
	/**
	 * 
	 */
	@SuppressWarnings("unchecked")
	private void initWeka() {
		_battAttributes = _battFeatures.getAttributes();
		
		_normalAttributes = new ArrayList<Attribute>();
		for (INormalFeatures feature : _normalFeatures ) {
			_normalAttributes.addAll(feature.getAttributes());
		}
		
		_classAttributes = new ArrayList<Attribute>();

		List<String> classVal = new ArrayList<String>(2);
		classVal.add("positive");
		classVal.add("negative");
		Attribute classAttribute = new Attribute("classification", classVal);
		_classAttributes.add(classAttribute);
		
		_attributes = _wh.addLists(_battAttributes, _normalAttributes,
				_classAttributes);
		_instances = new Instances("relation", _attributes, 0);
	}

	/**
	 * Sets up retrieval at a fixed interval.
	 */
	private void initExecutor() {
		_scheduledExecutor = Executors.newScheduledThreadPool(1);
		
		_scheduledExecutor.scheduleAtFixedRate(new Runnable() {
			public void run() {
				fetchSnapshot();
			}
		}, 1, 5, TimeUnit.SECONDS); 
	}
	
	@Override
	public IBinder onBind(Intent intent) {
		return _mBinder;
	}
	
	@Override
	public boolean onUnbind(Intent intent) {
		return true;
	}
	
	/**
	 * Gets the data from all of the features and puts them in 
	 * a format for Weka to read.
	 */
	public void fetchSnapshot() {
		Log.d(TAG, "fetchSnapshot!");
		
		_time.setToNow();
		
		IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
		Instance battInstances = _battFeatures.getInstance(registerReceiver(null, filter));
		
		ArrayList<Instance> normalInstanceList = new ArrayList<Instance>(_normalAttributes.size());
		for (INormalFeatures features : _normalFeatures) {
			normalInstanceList.add(features.getInstance());
		}
		_wh.resetAttributes(_normalAttributes);
		Instance normalInstances = _wh.mergeInstances(normalInstanceList);
		
		_wh.resetAttributes(_classAttributes);
		Instance classInstance = new DenseInstance(1);
		classInstance.setValue(
				_classAttributes.get(0), _wh.getClassification() );
		
		_wh.resetAttributes(_attributes);
		_instances.add(_wh.mergeInstances(
				battInstances, normalInstances, classInstance));
		_instances.setClassIndex(_attributes.size()-1);
		
		_wh.writeArff(_instances.toString());
	}
	
	public class MalwareBinder extends Binder {
		MalwareService getService() {
			return MalwareService.this;
		}
	}
}
